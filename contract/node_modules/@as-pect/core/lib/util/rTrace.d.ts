export const BLOCK_OVERHEAD: number;
export const OBJECT_OVERHEAD: 16;
export const TOTAL_OVERHEAD: number;
export class Rtrace {
    constructor(options: any);
    options: any;
    onerror: any;
    oninfo: any;
    memory: any;
    shadow: WebAssembly.Memory | null;
    shadowStart: number;
    refCounts: Map<any, any>;
    blocks: Map<any, any>;
    allocSites: Map<any, any>;
    allocCount: number;
    resizeCount: number;
    moveCount: number;
    freeCount: number;
    incrementCount: number;
    decrementCount: number;
    onalloc(ptr: any): void;
    onresize(ptr: any, oldSize: any): void;
    onmove(oldPtr: any, newPtr: any): void;
    onfree(ptr: any): void;
    onincrement(ptr: any): void;
    ondecrement(ptr: any): void;
    env: {
        load_ptr: (id: any, bytes: any, offset: any, address: any) => any;
        load_val_i32: (id: any, value: any) => any;
        load_val_i64: (id: any, value: any) => any;
        load_val_f32: (id: any, value: any) => any;
        load_val_f64: (id: any, value: any) => any;
        store_ptr: (id: any, bytes: any, offset: any, address: any) => any;
        store_val_i32: (id: any, value: any) => any;
        store_val_i64: (id: any, value: any) => any;
        store_val_f32: (id: any, value: any) => any;
        store_val_f64: (id: any, value: any) => any;
    };
    /** Synchronizes the shadow memory with the module's memory. */
    syncShadow(): void;
    /** Marks a block's presence in shadow memory. */
    markShadow(info: any, oldSize?: number): void;
    /** Unmarks a block's presence in shadow memory. */
    unmarkShadow(info: any, oldSize?: any): void;
    /** Performs an access to shadow memory. */
    accessShadow(ptr: any, size: any, isLoad: any): void;
    /** Obtains information about a block. */
    getBlockInfo(ptr: any): {
        ptr: any;
        size: number;
        header: {
            mmInfo: {
                tags: string[];
                size: number;
            };
            gcInfo: {
                buffered: boolean;
                color: string;
                rc: number;
            };
            gcInfo2: number;
            rtId: number;
            rtSize: number;
        };
    };
    /** Checks if rtrace is active, i.e. at least one event has occurred. */
    get active(): boolean;
    /** Checks if there are any leaks and emits them via `oninfo`. Returns the number of live blocks. */
    check(): number;
    load_ptr(id: any, bytes: any, offset: any, address: any): any;
    load_val_i32(id: any, value: any): any;
    load_val_i64(id: any, value: any): any;
    load_val_f32(id: any, value: any): any;
    load_val_f64(id: any, value: any): any;
    store_ptr(id: any, bytes: any, offset: any, address: any): any;
    store_val_i32(id: any, value: any): any;
    store_val_i64(id: any, value: any): any;
    store_val_f32(id: any, value: any): any;
    store_val_f64(id: any, value: any): any;
}
//# sourceMappingURL=rTrace.d.ts.map